// \file libc++ threading support
/*
* Nirvana runtime library.
*
* This is a part of the Nirvana project.
*
* Author: Igor Popov
*
* Copyright (c) 2025 Igor Popov.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this library.  If not, see <http://www.gnu.org/licenses/>.
*
* Send comments and/or bug reports to:
*  popov.nirvana@gmail.com
*/
#ifndef __EXTERNAL_THREADING
#define __EXTERNAL_THREADING
#pragma once

#include <__chrono/convert_to_timespec.h>
#include <__chrono/duration.h>
#include <__config>
#include <time.h>

_LIBCPP_BEGIN_NAMESPACE_STD

using __libcpp_timespec_t = ::timespec;

//
// Mutex
//
using __libcpp_mutex_t = int;
#define _LIBCPP_MUTEX_INITIALIZER 0

using __libcpp_recursive_mutex_t = int;

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_recursive_mutex_init (__libcpp_recursive_mutex_t*)
{
	return 0;
}

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
int __libcpp_recursive_mutex_lock (__libcpp_recursive_mutex_t*)
{
	return 0;
}

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS 
bool __libcpp_recursive_mutex_trylock (__libcpp_recursive_mutex_t*)
{
	return true;
}

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
int __libcpp_recursive_mutex_unlock (__libcpp_recursive_mutex_t*)
{
	return 0;
}

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_recursive_mutex_destroy (__libcpp_recursive_mutex_t*)
{
	return 0;
}

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
int __libcpp_mutex_lock (__libcpp_mutex_t*)
{
	return 0;
}

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
bool __libcpp_mutex_trylock (__libcpp_mutex_t*)
{
	return true;
}

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
int __libcpp_mutex_unlock (__libcpp_mutex_t*)
{
	return 0;
}

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_mutex_destroy (__libcpp_mutex_t*)
{
	return 0;
}

//
// Condition Variable
//
using __libcpp_condvar_t = int;
#define _LIBCPP_CONDVAR_INITIALIZER 0

_LIBCPP_HIDE_FROM_ABI int __libcpp_condvar_signal (__libcpp_condvar_t*);

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_condvar_broadcast (__libcpp_condvar_t*)
{
	return 0; // Used in __call_once
}

_LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
int __libcpp_condvar_wait (__libcpp_condvar_t*, __libcpp_mutex_t*);
_LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
int __libcpp_condvar_timedwait (__libcpp_condvar_t*, __libcpp_mutex_t*, __libcpp_timespec_t*);
_LIBCPP_HIDE_FROM_ABI int __libcpp_condvar_destroy (__libcpp_condvar_t*);

//
// Execute once
//
using __libcpp_exec_once_flag = void*;
#define _LIBCPP_EXEC_ONCE_INITIALIZER 0

_LIBCPP_HIDE_FROM_ABI int __libcpp_execute_once(__libcpp_exec_once_flag* control, void (*init_routine)());

//
// Thread id
//
using __libcpp_thread_id = int;

_LIBCPP_HIDE_FROM_ABI bool __libcpp_thread_id_equal(__libcpp_thread_id, __libcpp_thread_id);
_LIBCPP_HIDE_FROM_ABI bool __libcpp_thread_id_less(__libcpp_thread_id, __libcpp_thread_id);

//
// Thread
//
#define _LIBCPP_NULL_THREAD 0
using __libcpp_thread_t = int;

_LIBCPP_HIDE_FROM_ABI bool __libcpp_thread_isnull(const __libcpp_thread_t*);
_LIBCPP_HIDE_FROM_ABI int __libcpp_thread_create(__libcpp_thread_t*, void* (*__func)(void*), void* __arg);
_LIBCPP_HIDE_FROM_ABI __libcpp_thread_id __libcpp_thread_get_current_id();
_LIBCPP_HIDE_FROM_ABI __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t*);
_LIBCPP_HIDE_FROM_ABI int __libcpp_thread_join(__libcpp_thread_t*);
_LIBCPP_HIDE_FROM_ABI int __libcpp_thread_detach(__libcpp_thread_t*);

_LIBCPP_HIDE_FROM_ABI void __libcpp_thread_yield ();
_LIBCPP_HIDE_FROM_ABI void __libcpp_thread_sleep_for(const chrono::nanoseconds&);

//
// Thread local storage
//
#define _LIBCPP_TLS_DESTRUCTOR_CC /* nothing */
using __libcpp_tls_key = unsigned int;

_LIBCPP_HIDE_FROM_ABI int __libcpp_tls_create (__libcpp_tls_key* key, void (*deleter)(void*));
_LIBCPP_HIDE_FROM_ABI void* __libcpp_tls_get (__libcpp_tls_key key);
_LIBCPP_HIDE_FROM_ABI int __libcpp_tls_set (__libcpp_tls_key key, void* val);

_LIBCPP_END_NAMESPACE_STD

#endif
