// \file libc++ threading support
/*
* Nirvana runtime library.
*
* This is a part of the Nirvana project.
*
* Author: Igor Popov
*
* Copyright (c) 2025 Igor Popov.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this library.  If not, see <http://www.gnu.org/licenses/>.
*
* Send comments and/or bug reports to:
*  popov.nirvana@gmail.com
*/

#include <time.h>
#include <CORBA/CORBA.h>
#include <Nirvana/POSIX.h>
#include <Nirvana/Module.h>

_LIBCPP_BEGIN_NAMESPACE_STD

using __libcpp_timespec_t = ::timespec;

//
// Mutex
//
using __libcpp_mutex_t = int;
#define _LIBCPP_MUTEX_INITIALIZER 0

using __libcpp_recursive_mutex_t = int;


inline _LIBCPP_HIDE_FROM_ABI int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t*) { return true; }
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t*) { return 0; }

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_mutex_lock(__libcpp_mutex_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS bool __libcpp_mutex_trylock(__libcpp_mutex_t*) { return true; }
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_mutex_unlock(__libcpp_mutex_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI int __libcpp_mutex_destroy(__libcpp_mutex_t*) { return 0; }

//
// Condition Variable
//
using __libcpp_condvar_t = int;
#define _LIBCPP_CONDVAR_INITIALIZER 0

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_condvar_signal(__libcpp_condvar_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI int __libcpp_condvar_broadcast(__libcpp_condvar_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_condvar_wait(__libcpp_condvar_t*, __libcpp_mutex_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
int __libcpp_condvar_timedwait(__libcpp_condvar_t*, __libcpp_mutex_t*, __libcpp_timespec_t*) { return 0; }
inline _LIBCPP_HIDE_FROM_ABI int __libcpp_condvar_destroy(__libcpp_condvar_t*) { return 0; }

//
// Execute once
//
using __libcpp_exec_once_flag = void*;
#define _LIBCPP_EXEC_ONCE_INITIALIZER 0

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_execute_once(__libcpp_exec_once_flag* control, void (*init_routine)())
{
	Nirvana::the_posix->once (*control, init_routine);
	return 0;
}

//
// Thread id
//
using __libcpp_thread_id = int;

inline _LIBCPP_HIDE_FROM_ABI bool __libcpp_thread_id_equal(__libcpp_thread_id, __libcpp_thread_id)
{ NIRVANA_UNREACHABLE_CODE (); return true; }
inline _LIBCPP_HIDE_FROM_ABI bool __libcpp_thread_id_less(__libcpp_thread_id, __libcpp_thread_id)
{ NIRVANA_UNREACHABLE_CODE (); return false; }

//
// Thread
//
#define _LIBCPP_NULL_THREAD 0
using __libcpp_thread_t = int;

inline _LIBCPP_HIDE_FROM_ABI bool __libcpp_thread_isnull(const __libcpp_thread_t*)
{ NIRVANA_UNREACHABLE_CODE (); return true; }

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_thread_create(__libcpp_thread_t*, void* (*__func)(void*), void* __arg)
{ NIRVANA_UNREACHABLE_CODE (); return ENOTSUP; }

inline _LIBCPP_HIDE_FROM_ABI __libcpp_thread_id __libcpp_thread_get_current_id()
{ NIRVANA_UNREACHABLE_CODE (); return 0; }

inline _LIBCPP_HIDE_FROM_ABI __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t*)
{ NIRVANA_UNREACHABLE_CODE (); return 0; }

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_thread_join(__libcpp_thread_t*)
{ NIRVANA_UNREACHABLE_CODE (); return ENOTSUP; }

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_thread_detach(__libcpp_thread_t*)
{ NIRVANA_UNREACHABLE_CODE (); return ENOTSUP; }

inline _LIBCPP_HIDE_FROM_ABI void __libcpp_thread_yield ()
{
	Nirvana::the_posix->yield ();
}


inline _LIBCPP_HIDE_FROM_ABI void __libcpp_thread_sleep_for(const chrono::nanoseconds&)
{ NIRVANA_UNREACHABLE_CODE (); }

//
// Thread local storage
//
#define _LIBCPP_TLS_DESTRUCTOR_CC /* nothing */
using __libcpp_tls_key = unsigned int;

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_tls_create (__libcpp_tls_key* key, void (*deleter)(void*))
{
	int ret = EINVAL;
	try {
		*key = Nirvana::the_module->CS_alloc (deleter);
		ret = 0;
	} catch (const CORBA::SystemException& ex) {
		int e = Nirvana::get_minor_errno (ex.minor ());
		if (e)
			ret = e;
	} catch (...) {
	}
	return ret;
}

inline _LIBCPP_HIDE_FROM_ABI void* __libcpp_tls_get (__libcpp_tls_key key)
{
	try {
		return Nirvana::the_module->CS_get (key);
	} catch (...) {}
	return nullptr;
}

inline _LIBCPP_HIDE_FROM_ABI int __libcpp_tls_set (__libcpp_tls_key key, void* val)
{
	int ret = EINVAL;
	try {
		Nirvana::the_module->CS_set (key, val);
		ret = 0;
	} catch (const CORBA::SystemException& ex) {
		int e = Nirvana::get_minor_errno (ex.minor ());
		if (e)
			ret = e;
	} catch (...) {
	}
	return ret;
}

_LIBCPP_END_NAMESPACE_STD

