/// \file Database connection module.
/*
* Nirvana runtime library.
*
* This is a part of the Nirvana project.
*
* Author: Igor Popov
*
* Copyright (c) 2021 Igor Popov.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this library.  If not, see <http://www.gnu.org/licenses/>.
*
* Send comments and/or bug reports to:
*  popov.nirvana@gmail.com
*/
#ifndef NDBC_IDL_
#define NDBC_IDL_

/// \brief Database connectivity module.
/// Inspired by the JDBC API.
/// 
module NDBC {

/// \brief An exception that provides information on database access warnings.
/// 
/// Warnings are silently chained to the object whose method caused it to be reported.
/// Warnings may be retrieved from Connection, Statement, and ResultSet objects.
/// Trying to retrieve a warning on a connection after it has been closed will cause an exception
/// to be thrown.
/// Similarly, trying to retrieve a warning on a statement after it has been closed or on a result
/// set after it has been closed will cause an exception to be thrown.
/// Note that closing a statement also closes a result set that it might have produced.
/// 
struct SQLWarning
{
	/// The vendor - specific exception code for this SQLException object.
	long errorCode;

	/// the SQLState for this SQLException object.
	string sqlState;
};

typedef sequence <SQLWarning> SQLWarnings;

/// An exception that provides information on a database access error or other errors.
exception SQLException
{
	SQLWarning error;
	SQLWarnings next;
};

/// \brief Data type
enum DataType
{
	DB_BIGINT,    ///< 64-bit integer.
	DB_BINARY,    ///< Fixed size binary.
	DB_BIT,       ///< TRUE/FALSE.
	DB_CHAR,      ///< Fixed length character string.
	DB_DATE,      ///< Day number since 15 October 1582 00:00 of the Gregorian Calendar.
	DB_DATETIME,  ///< TimeT
	DB_DECIMAL,   ///< Fixed point value
	DB_DOUBLE,    ///< 64-bit floating-point value
	DB_FLOAT,     ///< 32-bit floating-point value
	DB_INT,       ///< 32-bit integer
	DB_NCHAR,     ///< Fixed length wide character string.
	DB_NVARCHAR,  ///< Variable length wide character data
	DB_SMALLINT,  ///< 16-bit integer
	DB_TIME,      ///< Time of day with fraction
	DB_TINYINT,   ///< Octet
	DB_VARCHAR,   ///< Variable length character data
	DB_NULL
};

typedef sequence <octet> Blob;

union Value switch (DataType)
{
case DB_BIGINT:
case DB_TIME:
case DB_DATETIME:
	long long ll_val;
case DB_BINARY:
	Blob blob;
case DB_BIT:
	boolean bool_val;
case DB_CHAR:
case DB_NCHAR:
case DB_VARCHAR:
case DB_NVARCHAR:
	string s_val;
case DB_DATE:
case DB_INT:
	long l_val;
case DB_DECIMAL:
	octet decimal [32];
case DB_DOUBLE:
	double dbl_val;
case DB_FLOAT:
	float flt_val;
case DB_SMALLINT:
	short si_val;
case DB_TINYINT:
	octet byte_val;
};

struct DataLength
{
	unsigned short length;
	short fraction;
};

struct Variant
{
	Value value;
	DataLength length;
};

typedef sequence <Variant> VariantSeq;

struct Column
{
	string name;
	DataType type;
	DataLength length;
};

typedef sequence <Column> Columns;

/// \brief The sequence of the consecutive records.
/// 
/// The encoding is depends on the ResultSet::flags & ResultSet::FLAG_LITTLE_ENDIAN.
/// 
/// For result sets with floating field positions, data is prefixed with array of 32-bit unsigned
/// ofsets.
typedef sequence <Blob> Records;

/// Array of the field offsets relative to the record begin.
/// The size of array is (field_count-1): offset of the first field is always zero.
typedef sequence <unsigned long> FieldOffsets;

interface Cursor
{
	Records getNext (in unsigned long from, in unsigned long max_cnt) raises (SQLException);
};

valuetype ResultSet
{
	const octet FLAG_LITTLE_ENDIAN = 0x01;

	private octet flags;

	/// The columns metadata.
	private Columns metadata;
	
	/// For result sets with floating field positions, this array is empty
	/// and each record is prefixed with array of N-1 32-bit offsets.
	private FieldOffsets field_offsets;

	/// Current record number. 0 - before the first record.
	private unsigned long position;

	/// Position of the current record in the records cache.
	private unsigned long cache_position;

	/// Fetched records cache.
	private Records records;

	private Cursor cursor;

	factory create (in Columns metadata, in FieldOffsets offsets, in Blob first_record, in NDBC::Cursor cur);
};

typedef unsigned short Ordinal;

interface Statement
{
	void close ();
	void clearWarnings ();
	boolean getMoreResults ();
	ResultSet getResultSet () raises (SQLException);
	long getUpdateCount () raises (SQLException);
	SQLWarnings getWarnings ();
};

interface PreparedStatement : Statement
{
	/// Prepare for mutiple-times execution.
	const short PREPARE_PERSISTENT = 1;

	void clearParameters ();
	void setInt (in Ordinal idx, in long v) raises (SQLException);
	void setIntByName (in string name, in long v) raises (SQLException);

	boolean execute () raises (SQLException);
};

interface CallableStatement : PreparedStatement
{};

interface Connection
{
	void abort ();
	attribute boolean autoCommit;
	attribute string catalog;
	void clearWarnings ();
	void close ();
	void commit ();
	Statement createStatement (in long resultSetType, in long resultSetConcurrency);
	SQLWarnings getWarnings ();
	attribute long holdability;
	attribute string schema;
	readonly attribute boolean isClosed;
	attribute boolean isReadOnly;
	readonly attribute boolean isValid;
	string nativeSQL (in string sql) raises (SQLException);
	CallableStatement prepareCall (in string sql) raises (SQLException);
	PreparedStatement prepareStatement (in string sql, in unsigned short flags);
	void rollback ();
	attribute short transactionIsolation;
};

interface DataSource
{
	Connection getConnection (in string user, in string pwd) raises (SQLException);
};

interface Driver
{
	DataSource getDataSource (in string url) raises (SQLException);
};

interface DriverFactory
{
	Driver getDriver ();
};

/// The basic service for managing a set of JDBC drivers.
interface DriverManager
{
	/// Attempts to make a database connection to the given URL.
	/// 
	/// \param url Data source URL.
	/// \param user Username (optional).
	/// \param pwd Password (optional).
	/// \returns Connection object.
	Connection getConnection (in string url, in string user, in string pwd) raises (SQLException);
};

};
